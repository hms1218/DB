CREATE TABLE PRODUCT(
	NO NUMBER PRIMARY KEY,
	NAME VARCHAR2(100) NOT NULL,
	PRICE NUMBER,
	P_DATE DATE
)
-- 컬럼명 변경
ALTER TABLE PRODUCT RENAME COLUMN "NO" TO NUM;
-- 컬럼타입 변경
ALTER TABLE PRODUCT MODIFY NAME VARCHAR2(200);
-- 컬럼추가
ALTER TABLE PRODUCT ADD AGE NUMBER;
-- 컬럼삭제
ALTER TABLE PRODUCT DROP COLUMN AGE;
-- 테이블이 이미 생성된 후 제약조건 추가
ALTER TABLE PRODUCT ADD CONSTRAINT PR_KEY PRIMARY KEY NAME;
-- 제약조건 삭제
ALTER TABLE PRODUCT DROP CONSTRAINT PR_KEY;

CREATE TABLE TBL_STUDENT(
	ID NUMBER,
	NAME VARCHAR2(100),
	MAJOR VARCHAR2(100),
	GENDER CHAR(1) DEFAULT 'M' NOT NULL CONSTRAINT BAN_CHAR CHECK(GENDER = 'M' OR GENDER = 'W');
	BIRTH DATE CONSTRAINT BAN_DATE CHECK(BIRTH >= TO_DATE('1980-01-01','YYYY-MM-DD')),
	CONSTRAINT STD_PK PRIMARY KEY(ID)	
);

CREATE TABLE "USER"(
	ID VARCHAR2(100) PRIMARY KEY,
	PW VARCHAR2(100),
	NAME VARCHAR2(50),
	ADDRESS VARCHAR2(100),
	EMAIL VARCHAR2(50),
	BIRTH DATE
)

CREATE TABLE PRODUCT(
	PRODUCT_NUM NUMBER PRIMARY KEY,
	PRDOUCT_NAME VARCHAR2(300),
	PRODUCT_PRICE NUMBER,
	PRODUCT_COUNT NUMBER
)

--주문테이블
CREATE TABLE "ORDER"(
	ORDER_NUM NUMBER PRIMARY KEY, -- 주문번호
	ORDER_DATE DATE,
	ID VARCHAR2(100),
	PRODUCT_NUM NUMBER,
	-- 외래키 설정(FOREIGN KEY)
	CONSTRAINT USER_FK FOREIGN KEY(ID) REFERENCES "USER"(ID);
	CONSTRAINT PRODUCT_FK FOREIGN KEY(PRODUCT_NUM) REFERENCES PRODUCT(PRODUCT_NUM);
)

--사원테이블에서 first_name(이름),job_id(직종),salary(급여)를 조회해보자!
SELECT FIRST_NAME,JOB_ID,SALARY FROM EMPLOYEES;

--사원테이블에서 사번, 이름,입사일,급여를 검색하시오
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE, SALARY FROM EMPLOYEES;

--사원테이블에서 사번, 이름, 직종, 급여, 보너스, 실제의 보너스 금액을 출력
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY, COMMISSION_PCT, SALARY*COMMISSION_PCT SC FROM EMPLOYEES;

--사원테이블에서 급여가 10000이상인 사원들의 정보를 사번, 이름, 급여 순으로 출력
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY FROM EMPLOYEES
WHERE SALARY >= 10000;

--사원테이블에서 이름이 Michael인 사원의 사번, 이름을 조회
SELECT EMPLOYEE_ID, FIRST_NAME FROM EMPLOYEES
WHERE FIRST_NAME = 'Michael'; -- 반드시 ''홑따옴표 사용해야함 ==아니고 =로 비교

--사원테이블에서 직종이 IT_PROG인 사원들의 정보를 사번, 이름, 직종, 급여 순으로 출력
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY FROM EMPLOYEES
WHERE JOB_ID = 'IT_PROG';

--사원테이블에서 입사일이 05년9월21일인 사원의 정보를 사번, 이름, 입사일 순으로 출력
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM EMPLOYEES
WHERE HIRE_DATE = '2005-09-21';

--사원테이블에서 06년도에 입사한 사원들의 정보를 사번, 이름, 직종, 입사일 순으로 출력
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM EMPLOYEES
WHERE HIRE_DATE >= '2006-01-01' AND HIRE_DATE <= '2006-12-31';

--사원테이블에서 급여가 5000이상이고 6000이하인 사원의 정보를 사번, 이름, 급여순으로 출력
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY FROM EMPLOYEES
--WHERE SALARY >= 5000 AND SALARY <= 6000;
WHERE SALARY BETWEEN 5000 AND 6000;

--직종이 SA_MAN , IT_PROG인 사원들의 정보를 이름, 직종순으로 출력
SELECT FIRST_NAME, JOB_ID FROM EMPLOYEES
--WHERE JOB_ID = 'SA_MAN' OR JOB_ID = 'IT_PROG';
WHERE JOB_ID IN ('SA_MAN','JOB_ID');

--급여가 2200, 3200, 5000을 받는 사원들의 정보를 이름, 직종, 급여순으로 출력하되 in연산자를 사용하시오
SELECT FIRST_NAME, JOB_ID, SALARY FROM EMPLOYEES e 
WHERE SALARY NOT IN (2200,3300,5000);
-- NOT IN

--LIKE연산자
-- % : 모든값
-- _ : 하나의 값
-- EX)M% : M으로 시작하는 모든값
-- EX)%A : A로 끝나는 모든값
-- EX)%A% : 어디든 A를 포함하고 있는 값
-- EX)%M%I% : M과 I를 포함하고 있는 데이터
-- EX)M____ : M으로 시작하는 5글자

SELECT TRUNC(1234.567,1),TRUNC(1234.567,-1),TRUNC(1234.567) FROM DUAL;

--각 부서별 급여의 평균과 총 합을 출력
SELECT DEPARTMENT_ID, COUNT(*), AVG(SALARY), SUM(SALARY) FROM EMPLOYEES 
GROUP BY DEPARTMENT_ID;

--부서별, 직종별로 그룹을 나눠서 인원수를 출력 단, 부서번호가 낮은순으로 정렬하시오.
SELECT DEPARTMENT_ID, JOB_ID, COUNT(*) FROM EMPLOYEES 
GROUP BY DEPARTMENT_ID, JOB_ID
ORDER BY DEPARTMENT_ID;

--각 부서의 급여의 최대값, 최소값, 인원수를 출력하자
--단, 급여의 최대값이 8000이상인 결과만 보여줄 것.
SELECT DEPARTMENT_ID, MAX(SALARY), MIN(SALARY), COUNT(*) FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING MAX(SALARY) >= 8000;
     
--사원테이블에서 이름이 'Michael'이고, 직종이 'MK_MAN'인 사원의 급여보다
--많이 받는 사원들의 정보를 사번, 이름, 직종, 급여 순으로 출력

--1)이름이 Michael이고, 직종이 'MK_MAN'인 사원의 급여 구하기
SELECT SALARY FROM EMPLOYEES
WHERE FIRST_NAME = 'Michael' AND JOB_ID = 'MK_MAN'; -- 급여 : 13000

--2)급여 13000보다 많이 받는 사원들의 정보를 사번, 이름, 직종, 급여 순으로 출력
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY FROM EMPLOYEES
WHERE SALARY > 
(SELECT SALARY FROM EMPLOYEES
WHERE FIRST_NAME = 'Michael' AND JOB_ID = 'MK_MAN');

--사번이 150번인 사원의 급여와 같은 급여를 받는 사원들의 정보를 사번, 이름, 급여 순으로 출력
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY FROM EMPLOYEES
WHERE SALARY = 
(SELECT SALARY FROM EMPLOYEES 
WHERE EMPLOYEE_ID = 150);

SELECT SALARY FROM EMPLOYEES 
WHERE EMPLOYEE_ID = 150;

--월급이 회사의 평균월급 이상인 사람들의 이름과 월급을 조회
SELECT AVG(SALARY) FROM EMPLOYEES; -- 6643.8878

SELECT FIRST_NAME, SALARY FROM EMPLOYEES
WHERE SALARY >= (SELECT AVG(SALARY) FROM EMPLOYEES);

--사번이 111번인 사원의 직종과 같고 사번이 159번인 사원의 급여보다 많이 받는 사원들의 정보를 사번, 이름, 직종, 급여 순으로 출력
SELECT JOB_ID FROM EMPLOYEES
WHERE EMPLOYEE_ID = 111; --FI_ACCOUNT

SELECT SALARY FROM EMPLOYEES e 
WHERE EMPLOYEE_ID = 159; -- 8000

SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY FROM EMPLOYEES
WHERE JOB_ID = 
(SELECT JOB_ID FROM EMPLOYEES
WHERE EMPLOYEE_ID = 111) AND 
SALARY > (SELECT SALARY FROM EMPLOYEES e 
WHERE EMPLOYEE_ID = 159);

--1) NO : 제품번호, 숫자, 기본키
--2) NAME : 제품명, 문자열 최대 100바이트, 필수
--3) PRICE : 제품가격, 숫자
--4) P_DATE : 생산일자, 날짜

CREATE TABLE PRODUCT(
	"NO" NUMBER PRIMARY KEY,
	NAME VARCAHR2(100) NOT NULL,
	PRICE NUMBER,
	P_DATE DATE
)

-- CD > 
-- TITLE (PK)
-- PRICE
-- GENRE
-- TRACKLIST
-- ARTIST_NAME FK(ARTIST->NAME)

-- ARTIST >
-- NAME (PK)
-- COUNTRY
-- DEBUTYEAR

-- TRACK >
-- TITLE (PK)
-- RUNNINGTIME
-- CD_TITLE FK(CD -> TITLE)

CREATE TABLE ARTIST(
	NAME VARCHAR2(100) PRIMARY KEY,
	COUNTRY VARCHAR2(100),
	DEBUTYEAR DATE
)

CREATE TABLE CD(
	TITLE VARCHAR2(100) PRIMARY KEY,
	PRICE NUMBER,
	GENRE VARCHAR2(100),
	TRACKLIST VARCHAR2(100),
	ARTIST_NAME VARCHAR2 FOREIGN KEY(ARTIST_NAME) REFERENCES ARTIST(NAME)
)

CREATE TABLE TRACK(
	TITLE VARCHAR2(100) PRIMARY KEY,
	RUNNINGTIME NUMBER,
	CD_TITLE VARCHAR2(100) FOREIGN KEY(CD_TITLE) REFERENCES CD(TITLE)
)

--회사는 네 개의 부서를 운영한다. 부서는 (부서번호, 부서이름)을 저장한다.
--부서는 1명 이상의 직원(직원번호, 직원이름, 직책)을 두고 있다. 각 직원은 하나의 부서에 소속된다.
--직원은 부양가족(이름, 나이)이 있을 수 있다.
--각 직원은 근무했던 부서에 대한 근무기록(기간)이 있다.

-- 부서 테이블
-- 부서번호(PK)
-- 부서이름

-- 직원 테이블
-- 직원번호(PK)
-- 직원이름
-- 직책
-- 부서번호(FK) -> 부서

-- 부양가족 테이블
-- 이름
-- 나이
-- 직원번호(FK) -> 직원

-- 근무기록 테이블
-- 기간
-- 직원번호(FK) -> 직원

--10번 및 30번 부서에 속하는 모든 사원 중 급여가 1500을 넘는 사원의사원번호,이름 및 급여를 조회하세요
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY FROM EMPLOYEES e 
WHERE DEPARTMENT_ID IN (10,30) AND SALARY > 1500;

--관리자가 없는 모든 사원의 이름 및 직종을 출력하세요
SELECT FIRST_NAME, JOB_ID FROM EMPLOYEES
WHERE MANAGER_ID IS NULL;

--직업이 IT_PROG 또는 SA_MAN 이면서 급여가 1000,3000,5000이 아닌 모든 사원들의 이름, 직종 및 급여를 조회하세요
SELECT FIRST_NAME, JOB_ID, SALARY FROM EMPLOYEES
WHERE JOB_ID IN ('IT_PROG','SA_MAN') AND SALARY NOT IN(1000,3000,5000);

--1) 모든 칼럼의 타입에 맞는 데이터를 삽입하고, 모든 칼럼에 널 값이 없도록 작성하시오.
--
--2) NO 칼럼의 데이터는 오라클 시퀀스를 활용하여 입력하시오. 시퀀스의 이름이나 속성은 알아서 처리하시오.
--
--3) P_DATE 칼럼의 데이터 중 하나 이상은 반드시 현재 날짜를 호출하는 오라클 함수를 사용하시오.

INSERT INTO PRODUCT("NO",NAME,PRICE,P_DATE) VALUES(1000,'컴퓨터',100,SYSDATE);
--NO 가 1000 인 데이터의 PRICE 를 20만큼 증가시키시오.
UPDATE PRODUCT
SET PRICE = PRICE+20
WHERE "NO" = 1000;

SELECT * FROM PRODUCT

--NAME 이 '세탁기' 인 데이터를 모두 삭제하시오.
DELETE FROM PRODUCT
WHERE NAME = '세탁기';

--모든 레코드와 모든 칼럼을 높은 PRICE가 먼저 나타나도록 정렬하여 조회하시오.
SELECT * FROM PRODUCT
ORDER BY PRICE DESC;

--부서번호가 50번인 사원들의 이름을 출력하되 이름중 'el'을 모두 '**'로 대체하여 출력하시오
SELECT REPLACE(FIRST_NAME, 'el', '**') FROM EMPLOYEES e 
WHERE DEPARTMENT_ID = 50;

-- 이름이 6글자 이상인 사원의 사번과 이름, 급여를 출력
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY FROM EMPLOYEES
WHERE LENGTH(FIRST_NAME)>=6;

--사원테이블에서 사원번호와 사원번호가 홀수이면 1, 짝수이면 0을 출력하시오.
SELECT EMPLOYEE_ID, MOD(EMPLOYEE_ID,2)FROM EMPLOYEES;

--사원번호가 짝수인 사람들의 사원 번호와 이름을 출력하시오.
SELECT EMPLOYEE_ID, FIRST_NAME FROM EMPLOYEES
WHERE MOD(EMPLOYEE_ID,2)=0;

--사원테이블에서 이름, 급여, 급여 1000당 0의 개수를 채워 조회하세요
SELECT FIRST_NAME, SALARY, RPAD('X',ROUND(SALARY/1000),'X') FROM EMPLOYEES;

--사원테이블에서 모든 사원의 입사일로부터 6개월 뒤의 날짜를 이름, 입사일, 6개월뒤 날짜 순으로 출력
SELECT FIRST_NAME, HIRE_DATE, ADD_MONTHS(HIRE_DATE,6) FROM EMPLOYEES;

--사번이 120번인 사원이 입사후 3년 6개월째 되는날 진급예정이다. 진급 예정 날짜를 구하시오.
SELECT ADD_MONTHS(HIRE_DATE,42) E FROM EMPLOYEES
WHERE EMPLOYEE_ID = 120;

--사원들의 이름, 입사일, 입사후 오늘까지의 개월수를 조회하되 입사기간이 200개월 이상인 사람만 출력하고 입사개월수는 소수점 이하 한자리까지만 버림하시오.
SELECT FIRST_NAME, HIRE_DATE, TRUNC(MONTHS_BETWEEN(SYSDATE,HIRE_DATE),1) FROM EMPLOYEES
WHERE TRUNC(MONTHS_BETWEEN(SYSDATE,HIRE_DATE),1) >= 200;

--입사기간이 160개월 이상인 사원들의 이름, 입사일, 입사후 개월수를 출력
SELECT FIRST_NAME, HIRE_DATE, TRUNC(MONTHS_BETWEEN(SYSDATE,HIRE_DATE)) FROM EMPLOYEES
WHERE TRUNC(MONTHS_BETWEEN(SYSDATE,HIRE_DATE)) >= 160;

--사번이 120번인 사원이 입사후 3년 6개월이 되는날 퇴사했다. 이 사원의 사번,이름,입사일,퇴사일을 출력
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE, ADD_MONTHS(HIRE_DATE,42) FROM EMPLOYEES
WHERE EMPLOYEE_ID = 120;

--사원테이블에서 직종이 SA_REP인 사원들의 평균급여, 급여최고액, 급여최저액, 급여의 총 합계를 출력하시오.
SELECT AVG(SALARY), MAX(SALARY), MIN(SALARY), SUM(SALARY) FROM EMPLOYEES
WHERE JOB_ID = 'SA_REP';

--부서번호가 80번인 부서의 사원들의 급여의 평균을 출력
SELECT AVG(SALARY) FROM EMPLOYEES
WHERE DEPARTMENT_ID = 80;

SELECT * FROM EMPLOYEES;

--사원 테이블에 등록되어있는 모든 사원의 수, 보너스를 받는 인원수, 전체사원 급여의 평균, 등록되어있는 부서의 갯수를 화면에 출력
SELECT COUNT(EMPLOYEE_ID), COUNT(COMMISSION_PCT), COUNT(SALARY), COUNT(DEPARTMENT_ID) FROM EMPLOYEES;

--사원테이블에서 80번 부서에 속하는 사원들의 연봉의 평균을 소수점 두자리까지 반올림하여 출력하시오
SELECT ROUND(AVG(SALARY),2) FROM EMPLOYEES
WHERE DEPARTMENT_ID = 80;

--사원테이블에서 50번에 속하는 사원들의 급여의 최대값과 최소값을 출력하세요
SELECT MAX(SALARY), MIN(SALARY) FROM EMPLOYEES e 
WHERE DEPARTMENT_ID = 50;

-- 직종별 인원수를 출력
SELECT JOB_ID,COUNT(*) FROM EMPLOYEES e
GROUP BY JOB_ID;

--각 직종별 급여의 합을 출력
SELECT JOB_ID, SUM(SALARY) FROM EMPLOYEES
GROUP BY JOB_ID;

--부서별로 가장 높은 급여를 조회
SELECT DEPARTMENT_ID, MAX(SALARY) FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;

--부서별 급여의 합계를 내림차순으로 조회
SELECT DEPARTMENT_ID, SUM(SALARY) FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
ORDER BY SUM(SALARY) DESC;

--각 부서별 인원수가 20명 이상인 부서의 정보를 부서번호, 급여의 합, 
--급여의 평균, 인원수 순으로 출력 단, 급여의 평균은 소수점 2자리 반올림
SELECT DEPARTMENT_ID, SUM(SALARY), ROUND(AVG(SALARY),2), COUNT(*) FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING COUNT(*) >= 20;

--부서별, 직종별로 그룹화 하여 결과를 부서번호, 직종, 인원수 순으로 출력, 단, 직종이 'MAN'으로 끝나는 경우만 출력
SELECT DEPARTMENT_ID, JOB_ID, COUNT(*) FROM EMPLOYEES
WHERE JOB_ID LIKE '%MAN'
GROUP BY DEPARTMENT_ID, JOB_ID;

--각 부서별 평균 급여를 소수점 한자리까지 버림으로 출력 단, 평균 급여가 10000미만인 그룹만 조회해야 하며 부서번호가 50이하인 부서만 조회
SELECT TRUNC(AVG(SALARY),1) FROM EMPLOYEES
WHERE DEPARTMENT_ID <= 50
GROUP BY DEPARTMENT_ID
HAVING AVG(SALARY) < 10000;

--각 부서별 부서번호, 급여의 합, 평균, 인원수 순으로 출력 
--단, 급여의 합이 30000이상인 경우만 출력해야 하며, 급여의 평균은 소수점 2자리에서 반올림 하시오.
SELECT DEPARTMENT_ID, SUM(SALARY), ROUND(AVG(SALARY),1), COUNT(*) FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING SUM(SALARY) >= 30000;

--EMPLOYEES 테이블에서 100번 부서의 최소 급여보다 최소 급여가 많은 다른 모든 부서를 출력하라
SELECT MIN(SALARY) FROM EMPLOYEES
WHERE DEPARTMENT_ID = 100; -- 6900

SELECT DEPARTMENT_ID FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING MIN(SALARY) > (SELECT MIN(SALARY) FROM EMPLOYEES
WHERE DEPARTMENT_ID = 100);

--EMPLOYEES 테이블에서 (50번 부서의 최고 급여)를 받는 사원 보다 많은 급여를 받는 
--사원의 사원번호,이름,업무,입사일자,급여,부서번호를 출력하라.
SELECT MAX(SALARY) FROM EMPLOYEES
WHERE DEPARTMENT_ID = 50; -- 8200

SELECT EMPLOYEE_ID,FIRST_NAME,JOB_ID,HIRE_DATE,SALARY,DEPARTMENT_ID FROM EMPLOYEES
WHERE SALARY > (SELECT MAX(SALARY) FROM EMPLOYEES
WHERE DEPARTMENT_ID = 50) AND DEPARTMENT_ID NOT IN(50);

--EMPLOYEES 테이블에서 사원들의 이름 연결하기
--CONCATENATION(연결)
SELECT FIRST_NAME||' '||LAST_NAME FROM EMPLOYEES;

--OO의 급여는 OO이다.
SELECT FIRST_NAME||'의 급여는 '||SALARY||'이다.' FROM EMPLOYEES;

--INNER JOIN
--테이블명A INNER JOIN 테이블명B ON 조건식
--테이블명A JOIN 테이블명B ON 조건식

SELECT E.DEPARMENT_ID, D.DEPARTMENT_ID FROM EMPLOYEES.E, DEPARTMENTS d;

SELECT E.FIRST_NAME, E.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

SELECT * FROM EMPLOYEES;

SELECT * FROM DEPARTMENTS d;

SELECT * FROM LOCATIONS;

SELECT * FROM COUNTRIES;

SELECT * FROM JOBS;
-- 부서 테이블과 지역(Locations)로부터 부서명과 city조회하기
SELECT D.DEPARTMENT_NAME, L.CITY
FROM DEPARTMENTS D JOIN LOCATIONS L
ON D.LOCATION_ID = L.LOCATION_ID;

-- 지역(Locations), 나라(countries)를 조회하여 도시명과 국가명을 조회
SELECT L.CITY, C.COUNTRY_NAME
FROM LOCATIONS L JOIN COUNTRIES C
ON L.COUNTRY_ID = C.COUNTRY_ID;

-- 사원 테이블과, JOBS 테이블을 이용하여 이름,성, 직종번호, 직종 이름을 조회하세요
SELECT E.FIRST_NAME, E.LAST_NAME, E.JOB_ID, J.JOB_TITLE
FROM EMPLOYEES e JOIN JOBS j 
ON E.JOB_ID = J.JOB_ID;

-- 사원,부서,지역테이블로부터 이름, 이메일, 부서번호, 부서명, 지역번호, 도시명을 조회하되,
-- 도시가 'Seattle'인 경우 조회하기
SELECT E.FIRST_NAME, E.EMAIL, E.DEPARTMENT_ID, D.DEPARTMENT_NAME, L.LOCATION_ID, L.CITY
FROM EMPLOYEES e JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
AND CITY = 'Seattle';

--1-1 SELF INNER JOIN
/*
 * SELECT a.컬럼1, b.컬럼1
 * FROM 테이블A a
 * JOIN 테이블A b
 * ON a.열 = b.열;
 * */

SELECT E2.FIRST_NAME, E2.EMPLOYEE_ID
FROM EMPLOYEES E1 JOIN EMPLOYEES E2
ON E1.EMPLOYEE_ID = E2.MANAGER_ID;

SELECT FIRST_NAME, EMPLOYEE_ID, MANAGER_ID FROM EMPLOYEES;

--CROSS INNER JOIN
--두 개 이상의 테이블에서 '모든 가능한 조합'을 만들어 결과를 반환하는 조인 방법

CREATE TABLE 테이블A(
   A_id NUMBER,
   A_name varchar2(10)
);

CREATE TABLE 테이블B(
   B_id NUMBER,
   B_name varchar2(20)
);

INSERT INTO 테이블A values(1, 'John');
INSERT INTO 테이블A values(2, 'Jane');
INSERT INTO 테이블A values(3, 'Bob');

INSERT INTO 테이블B values(101, 'Apple');
INSERT INTO 테이블B values(102, 'Banana');

SELECT * FROM 테이블A CROSS JOIN 테이블B;

-- 사원 테이블과 부서 테이블의 LEFT OUTER JOIN을 이용하여 사원이 어느부서에 있는지 조회하기(이름,부서명)
SELECT E.FIRST_NAME, D.DEPARTMENT_NAME
FROM EMPLOYEES e LEFT OUTER JOIN DEPARTMENTS d 
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

SELECT E.FIRST_NAME, D.DEPARTMENT_NAME
FROM EMPLOYEES E RIGHT OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

-- FULL OUTER JOIN

SELECT FIRST_NAME, DEPARTMENT_NAME
FROM EMPLOYEES E FULL OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

-- 부서번호, 사원명, 직업, 위치를 EMP와 DEPT 테이블을 통해 INNER JOIN하여 조회하기
SELECT * FROM EMP; -- 직업: JOB 사원명:ENAME 부서번호:DEPTNO
SELECT * FROM DEPT; -- 부서번호:DEPTNO 위치:LOC 부서명:DNAME

SELECT E.DEPTNO, E.ENAME, E.JOB, D.LOC
FROM EMP E INNER JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;

-- PLAYER테이블, TEAM테이블에서 송종국선수가 속한 팀의 전화번호 조회하기
-- 팀 아이디, 선수 이름, 전화번호 조회
SELECT * FROM PLAYER
WHERE PLAYER_NAME = '송종국'; - K06

SELECT * FROM TEAM
WHERE TEAM_ID = 'K06';

SELECT P.TEAM_ID, P.PLAYER_NAME, T.TEL
FROM PLAYER P JOIN TEAM T
ON P.TEAM_ID = T.TEAM_ID
AND P.PLAYER_NAME = '송종국';

-- JOBS테이블과 EMPLOYEES테이블에서 
-- 직종번호, 직종이름, 이메일, 이름과 성(연결) 별칭을 이름으로 하고 조회
SELECT * FROM JOBS; -- JOB_ID, JOB_TITLE

SELECT * FROM EMPLOYEES; -- JOB_ID, EMAIL, FIRST_NAME, LAST_NAME

SELECT J.JOB_ID, J.JOB_TITLE, E.EMAIL, E.FIRST_NAME||' '||E.LAST_NAME 이름
FROM JOBS J JOIN EMPLOYEES E
ON J.JOB_ID = E.JOB_ID;

SELECT * FROM EMP JOIN DEPT
USING(DEPTNO);

-- DEPT테이블의 LOC별 평균 SAL을 반올림한 값과, SAL의 총합을 조회해주세요
SELECT D.LOC, ROUND(AVG(SAL)), SUM(SAL) 
FROM DEPT D JOIN EMP E
ON D.DEPTNO = E.DEPTNO
GROUP BY D.LOC;

SELECT * FROM DEPT;

SELECT * FROM EMP; -- SAL

-- VIEW의 생성
-- OR REPLACE 옵션은 기존의 정의를 변경하는 데 사용할 수 있다.
/*
 * CREATE OR REPLACE VIEW 뷰이름 AS(
 * 		쿼리문
 * )
 * */

-- VIEW의 삭제
-- DROP VIEW 뷰이름

SELECT * FROM PLAYER;
-- 선수의 이름과 나이를 조회
-- EX) 홍길동 35

-- PLAYER_NAME, BIRTH_DATE

SELECT PLAYER_NAME, ROUND((SYSDATE-BIRTH_DATE)/365) 나이 FROM PLAYER;

--VIEW 이용
CREATE OR REPLACE VIEW PLAYER_AGE AS(
	SELECT ROUND((SYSDATE-BIRTH_DATE)/365) AGE, P.* FROM PLAYER P
)

SELECT * FROM PLAYER_AGE;

-- 30살이 넘은 선수를 조회
SELECT * FROM PLAYER_AGE
WHERE AGE > 30;

-- 사원이름과 상사이름을 조회하기
-- 이름과 성을 연결해서 사원은 ENAME, 상사는 MNAME
SELECT * FROM EMPLOYEES; -- FIRST_NAME,LAST_NAME

SELECT E1.FIRST_NAME||' '||E1.LAST_NAME ENAME , E2.FIRST_NAME||' '||E2.LAST_NAME MNAME
	FROM EMPLOYEES E1 JOIN EMPLOYEES E2
	ON E1.MANAGER_ID = E2.EMPLOYEE_ID;

CREATE OR REPLACE VIEW EMPLOYEES_MANAGER AS(
	SELECT E1.FIRST_NAME||' '||E1.LAST_NAME ENAME , E2.FIRST_NAME||' '||E2.LAST_NAME MNAME
	FROM EMPLOYEES E1 JOIN EMPLOYEES E2
	ON E1.MANAGER_ID = E2.EMPLOYEE_ID
);

SELECT * FROM EMPLOYEES_MANAGER;	

-- King Steven의 부하직원이 몇명인지 조회하세요.
SELECT COUNT(*) FROM EMPLOYEES_MANAGER
WHERE MNAME = 'Steven King';

-- PLAYER 테이블에 TEAM_NAME 컬럼을 추가한 VIEW 만들기
-- VIEW 이름은 PLAYER_TEAM_NAME

SELECT * FROM PLAYER;

SELECT * FROM TEAM;

CREATE OR REPLACE VIEW PLAYER_TEAM_NAME AS(
	SELECT T.TEAM_NAME, P.*
	FROM PLAYER P JOIN TEAM T
	ON P.TEAM_ID = T.TEAM_ID
);

SELECT * FROM PLAYER_TEAM_NAME;

-- TEAM_NAME이 '울산현대'인 선수들을 조회하세요
SELECT * FROM PLAYER_TEAM_NAME
WHERE TEAM_NAME = '울산현대';

-- HOMETEAM_ID, STADIUM_NAME, TEAM_NAME을 조회
-- HOMETEAM이 없는 경기장 이름도 나와야함

SELECT * FROM TEAM; -- TEAM_NAME, STADIUM_ID
SELECT * FROM STADIUM; -- HOMETEAM_ID, STADIUM_NAME, STADIUM_ID

CREATE OR REPLACE VIEW STADIUM_INFO AS(
	SELECT S.HOMETEAM_ID, S.STADIUM_NAME, T.TEAM_NAME
	FROM TEAM T RIGHT OUTER JOIN STADIUM S
	ON T.STADIUM_ID = S.STADIUM_ID
);

SELECT * FROM STADIUM_INFO;

-- 홈팀이 없는 경기장 검색하기
SELECT * FROM STADIUM_INFO
WHERE HOMETEAM_ID IS NULL;

-- 사원 테이블에서 급여, 급여를 많이 받는 순으로 순위를 조회
-- DATA_PLUS라는 VIEW에 저장
SELECT * FROM EMPLOYEES;

CREATE OR REPLACE VIEW DATA_PLUS AS(
	SELECT FIRST_NAME,SALARY, RANK() OVER(ORDER BY SALARY DESC) "RANK" FROM EMPLOYEES
);

SELECT * FROM DATA_PLUS;

-- 1등인 사람
SELECT * FROM DATA_PLUS dp 
WHERE RANK = 1;

-- 1~10등인 사람
SELECT * FROM DATA_PLUS
WHERE RANK BETWEEN 1 AND 10;

-- CASE문
-- 데이터의 값을 WHEN의 조건과 차례대로 비교한 후 일치하는 값을 찾아
-- THEN 뒤에 있는 결과값을 반환한다.

SELECT * FROM EMP;

SELECT ENAME, 
		DEPTNO,
		CASE
			WHEN DEPTNO = 10 THEN 'NEW YORK'
			WHEN DEPTNO = 20 THEN 'DALLAS'
			ELSE 'UNKNOWN'
		END AS LOC_NAME
FROM EMP
WHERE JOB='MANAGER';

SELECT ROUND(AVG(CASE WHEN JOB_ID = 'IT_PROG' THEN SALARY END),2) FROM EMPLOYEES;

SELECT ROUND(AVG(CASE JOB_ID WHEN 'IT_PROG' THEN SALARY END),2)
FROM EMPLOYEES;

SELECT JOB_ID, CASE WHEN JOB_ID = 'IT_PROG' THEN SALARY END FROM EMPLOYEES;

-- WHERE절에서의 사용
SELECT ENAME,SAL,
	CASE
		WHEN SAL >= 2900 THEN '1등급'
		WHEN SAL >= 2700 THEN '2등급'
		WHEN SAL >= 2000 THEN '3등급'
	END AS SAL_GRADE
FROM EMP
WHERE JOB = 'MANAGER' AND
(CASE 
	WHEN SAL >= 2900 THEN 1
	WHEN SAL >= 2700 THEN 2
	WHEN SAL >= 2000 THEN 3	
END) = 1;

-- EMP테이블에서 SAL이 3000이상이면 HIGH, 1000이상이면 MID, 다 아니면 LOW를 ENAME,SAL,GRADE순으로 조회
SELECT ENAME,SAL,
	CASE
		WHEN SAL >= 3000 THEN 'HIGH'
		WHEN SAL >= 1000 THEN 'MID'
		ELSE 'LOW'
	END AS GRADE
FROM EMP;
	
DECLARE
	V_MESSAGE VARCHAR2(100); -- 변수선언
BEGIN
	V_MESSAGE := 'HELLO';
	DBMS_OUTPUT.PUT_LINE(V_MESSAGE);
END;

DECLARE
	SALARY NUMBER := 5000;
BEGIN
	IF SALARY < 3000 THEN DBMS_OUTPUT.PUT_LINE('급여가 낮습니다.');
	ELSIF SALARY BETWEEN 3000 AND 7000 THEN DBMS_OUTPUT.PUT_LINE('급여가 중간입니다.');
	ELSE DBMS_OUTPUT.PUT_LINE('급여가 높습니다.');
	END IF;
END;

-- SCORE 변수에 80을 대입하고 
-- GRADE VARCHAR2(5)에 어떤 학점인지 대입하여 출력하기
-- 90점 이상은 A, 80점 이상은 B, 70점 이상은 C, 60점 이상은 D, 그 이하는 F
-- EX) 당신의 점수 80점, 학점 B
DECLARE
	SCORE NUMBER := 80;
	GRADE VARCHAR2(5);
BEGIN
	IF SCORE >= 90 THEN GRADE := 'A';
	ELSIF SCORE >= 80 THEN GRADE := 'B';
	ELSIF SCORE >= 70 THEN GRADE := 'C';
	ELSIF SCORE >= 60 THEN GRADE := 'D';
	ELSE GRADE := 'F';
	END IF;
	DBMS_OUTPUT.PUT_LINE('당신의 점수 '||SCORE||'점,'||' 학점 '||GRADE);
END;

-- FOR문
-- FOR 변수 IN 시작값..END값 LOOP
-- 반복하고자 하는 명령;
-- END LOOP;

BEGIN
	FOR I IN 1..10 LOOP
		DBMS_OUTPUT.PUT_LINE('I의 값: '||I);
	END LOOP;
END;

-- 1부터 10까지 
-- X는 짝수입니다.
-- X는 홀수입니다.
-- 출력하기

BEGIN
	FOR X IN 1..10 LOOP
		IF MOD(X,2)=0 THEN DBMS_OUTPUT.PUT_LINE(X||'는 짝수입니다.');
		ELSE DBMS_OUTPUT.PUT_LINE(X||'는 홀수입니다.');
		END IF;
	END LOOP;
END;

-- WHILE 조건 LOOP
-- 		반복한 문장
-- END LOOP;

-- 1부터 10까지 총합 구해서 출력
-- EX) 총합 : XX

DECLARE
	I NUMBER := 1;
	TOTAL NUMBER := 0;
BEGIN
	WHILE I <= 10 LOOP
		TOTAL := TOTAL + I;
		I := I + 1;
	END LOOP;
	DBMS_OUTPUT.PUT_LINE('총합 : '||TOTAL);
END;

--DCL

--GRANT : 권한부여
--REVOKE : 권한강탈

--데이터베이스에 접근하고 객체들을 사용하도록 권한을 주고 회수하는 명령어

--1) 테이블 스페이스 이름 : user_exam
--
--2) 데이터 파일 이름 : C:/Exam/user_exam.dbf
--
--3) 용량 : 10MB

CREATE TABLESPACE user_exam DATAFILE 'C:/Exam/user_exam.dbf' SIZE 10M;

--생성된 계정의 이름을 검색하기 위한 쿼리문을 작성하시오.

SELECT USERNAME FROM DBA_USERS;

--계정을 생성하는쿼리문 작성하기
CREATE USER ID IDENTIFIED BY PASSWORD;

--생성된 테이블 스페이스를 확인하기 위해서 테이블 스페이스의 목록을 조회할 수 있는 쿼리문을 작성하시오.
SELECT * FROM TABLESPACES;

--다음 조건을 만족하는 사용자를 생성하는 명령어를 작성하시오.
--사용자 ID : joe
--비밀번호 : black
--기본 tablespace : hr_data01
--temporary tablespace : temp
CREATE USER joe IDENTIFIED BY black DEFAULT TABLESPACE hr_data01 TEMPORARY TABLESPACE temp;

--릴레이션, 속성, 튜플에 대해서 설명하시오.
-- 릴레이션 : 데이터를 표의 형태로 표현한 것
-- 속성 : 데이터베이스를 구성하는 가장 작은 논리적 단위
-- 튜플 : 릴레이션을 구성하는 각각의 행

--테이블 이름:employees_demo
-- 각 속성이름 및 데이터형 : employee_id NUMBER(6),
--                           last_name VARCHAR2(25), 
--                           phone_number VARCHAR2(20),
--                           hire_date DATE, salary NUMBER(8,2), 
--                           department_id NUMBER(4)이다.

CREATE TABLE EMPLOYEES_DEMO(
	EMPLOYEE_ID NUMBER(6),
	LAST_NAME VARCHAR2(25),
	PHONE_NUMBER VARCHAR2(20),
	HIRE_DATE DATE,
	SALARY NUMBER(8,2),
	DEPARTMENT_ID NUMBER(4)
)

-- 뷰의 정의
-- 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상테이블이다.
-- 하나 이상의 테이블이나 다른 뷰의 데이터를 볼 수 있게 하는 데이터베이스 객체이다.

--뷰 이름:clerk 
--조건: employees 테이블에서 job_id가 'PU_CLERK' 이거나 'SH_CLERK'인 자료 중 
--컬럼이 employee_id, last_name, department_id, job_id를 select하여 만든다.

CREATE OR REPLACE VIEW CLERK AS(
	SELECT EMPLOYEE_ID, LAST_NAME, DAPARTMENT_ID, JOB_ID FROM EMPLOYEES
	WHERE JOB_ID IN ('PU_CLERK','SH_CLERK')
);

--테이블 스페이스를 생성하시오
--테이블 스페이스를 생성하는데 용량은 500MB로 성정하고 자동확장 기능(무한)을 사용한다.
--테이블 스페이스 명은 custom_space 데이터 파일명은 c:custom_space.dbf 로 지정한다.
CREATE TABLESPACE CUSTOM_SPACE DATAFILE 'c:custom_space.dbf' SIZE 500M AUTOEXTEND ON NEXT 100M MAXSIZE UNLIMITED;

--사용자를 생성하고 권한을 주시오.
--사용자 생성을 하나 하여(계정명 NAM2626) 접속 권한과 DDL 권한, 뷰 생성 권한만 주시오.
--테이블 스페이스는 1번에서 만든걸로 지정하시오.
CREATE USER NAM2626 IDENTIFIED BY 123456 DEFAULT TABLESPACE USER_TABLE;
GRANT CONNECT, RESOURCE, CREATE VIEW TO NAM2626;

--테이블 이름:employees_demo
--각 속성이름 및 데이터형 : employee_id NUMBER(6),
--                          last_name VARCHAR2(25), 
--                          phone_number VARCHAR2(20),
--                          hire_date DATE, salary NUMBER(8,2), 
--                          department_id NUMBER(4)이다.


-- 트랜잭션의 특성
-- 원자성 : 원자와 같이 데이터베이스 연산들이 나눌수도, 줄일수 없는 하나의 유닛으로서 취급됨 / 계좌
-- 원자성 : 트랜잭션의 연산은 모두 성공이거나 모두 실패여야한다.
-- 일관성 : 트랜잭션 실행전의 내용이 정상이라면 실행후의 내용도 정상이어야 한다.
-- 고립성 : 트랜잭션 실행 도중 다른 트랜잭션의 영향을 받는 것을 방지
-- 지속성 : 트랜잭션의 결과가 성공적이라면 갱신된 내용은 영구적이어야 한다.

-- TCL종류
-- COMMIT : DML로 변경된 데이터를 데이터베이스에 적용할 때 사용
-- ROLLBACK : DML로 변경된 데이터를 변경 이전 상태로 되돌릴 때 사용
-- SAVEPOINT

















































SELECT * FROM EMPLOYEES;

SELECT * FROM DEPARTMENTS;

SELECT AVG(SALARY) FROM EMPLOYEES; -- 6643.8878

SELECT EMPLOYEE_ID,SALARY FROM EMPLOYEES
WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEES);

--employees 테이블에서 부서가 '개발팀'(DEPT_ ID: 10)인 직원들 중,
--전체 직원의 평균 급여보다 낮은 급여를 받는 직원들의 급여를 10% 인상하시오.

SELECT EMPLOYEE_ID,SALARY FROM EMPLOYEES
WHERE SALARY < (SELECT AVG(SALARY) FROM EMPLOYEES)
AND DEPARTMENT_ID = 10;

SELECT * FROM EMPLOYEES
WHERE DEPARTMENT_ID = 10;

UPDATE EMPLOYEES
SET SALARY = SALARY * 1.1
WHERE SALARY < (SELECT AVG(SALARY) FROM EMPLOYEES) AND DEPARTMENT_ID = 10;

--employees 테이블에서 퇴사한 직원(퇴사일자가 존재하는 경우)의 정보를 삭제하시오.
--테이블 구조 참고
--employees(emp_id, name, hire_date, resign_date)

SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM EMPLOYEES;

DELETE FROM EMPLOYEES
WHERE RESIGN_DATE NOT IS NULL;

ALTER TABLE 테이블명 ADD CONSTRAINT [제약조건명] [제약조건 종류](컬럼명);
ALTER TABLE ex2_10 ADD CONSTRAINT pk_ex2_10 PRIMARY KEY(Col11);

ALTER TABLE PRODUCTS ADD CONSTRAINT NUMBER > 0 (PRICE);

ALTER TABLE PRODCUTS ADD CONSTRAINT NOT NULL(STOCK);

